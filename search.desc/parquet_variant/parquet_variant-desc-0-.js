searchState.loadedDescShard("parquet_variant", 0, "Implementation of Variant Binary Encoding from Apache …\nPrimitive (type_id=1): BINARY\nPrimitive (type_id=1): BOOLEAN (false)\nPrimitive (type_id=1): BOOLEAN (true)\nPrimitive (type_id=1): DATE\nPrimitive (type_id=1): DECIMAL(precision, scale) 128-bits\nPrimitive (type_id=1): DECIMAL(precision, scale) 32-bits\nPrimitive (type_id=1): DECIMAL(precision, scale) 64-bits\nPrimitive (type_id=1): DOUBLE\nPrimitive (type_id=1): FLOAT\nPrimitive (type_id=1): INT(16, SIGNED)\nPrimitive (type_id=1): INT(32, SIGNED)\nPrimitive (type_id=1): INT(64, SIGNED)\nPrimitive (type_id=1): INT(8, SIGNED)\nArray (type_id=4): N/A\nA builder for creating <code>Variant::List</code> values.\nPrimitive type: Null\nObject (type_id=3): N/A\nA builder for creating <code>Variant::Object</code> values.\nShort String (type_id=2): STRING\nPrimitive (type_id=1): STRING\nPrimitive (type_id=1): TIMESTAMP(isAdjustedToUTC=true, …\nPrimitive (type_id=1): TIMESTAMP(isAdjustedToUTC=false, …\nRepresents a Parquet Variant\nBuilder for <code>Variant</code> values\n<code>Variant</code> Array.\n<code>Variant</code> Metadata\nA <code>Variant</code> Object (struct with named fields).\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nA builder for creating <code>Variant::List</code> values.\nA builder for creating <code>Variant::Object</code> values.\nBuilder for <code>Variant</code> values\nAdd key to dictionary, return its ID\nAdd a field with key and value to the object\nFinalize object with sorted fields\nHelper to make room for header by moving data\nCreate an <code>ListBuilder</code> for creating <code>Variant::List</code> values.\nCreate an <code>ObjectBuilder</code> for creating <code>Variant::Object</code> …\nWrite little-endian integer to buffer\nDecodes a Binary from the value section of a variant.\nDecodes a Date from the value section of a variant.\nDecodes a Decimal16 from the value section of a variant.\nDecodes a Decimal4 from the value section of a variant.\nDecodes a Decimal8 from the value section of a variant.\nDecodes a Double from the value section of a variant.\nDecodes a Float from the value section of a variant.\nDecodes an Int16 from the value section of a variant.\nDecodes an Int32 from the value section of a variant.\nDecodes an Int64 from the value section of a variant.\nDecodes an Int8 from the value section of a variant.\nDecodes a long string from the value section of a variant.\nDecodes a short string from the value section of a variant.\nDecodes a TimestampMicros from the value section of a …\nDecodes a TimestampNtzMicros from the value section of a …\nReturns the argument unchanged.\nReturns the argument unchanged.\nExtracts the basic type from a header byte\nExtract the primitive type from a Variant value-metadata …\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nTo be used in <code>map_err</code> when unpacking an integer from a …\nTo be used in <code>map_err</code> when unpacking an integer from a …\nHelper to get a &amp;str from a slice based on range, if it’…\nPerforms a binary search over a range using a fallible key …\nAttempts to prove a fallible iterator is actually …\nPrimitive (type_id=1): BINARY\nPrimitive (type_id=1): BOOLEAN (false)\nPrimitive (type_id=1): BOOLEAN (true)\nPrimitive (type_id=1): DATE\nPrimitive (type_id=1): DECIMAL(precision, scale) 128-bits\nPrimitive (type_id=1): DECIMAL(precision, scale) 32-bits\nPrimitive (type_id=1): DECIMAL(precision, scale) 64-bits\nPrimitive (type_id=1): DOUBLE\nPrimitive (type_id=1): FLOAT\nPrimitive (type_id=1): INT(16, SIGNED)\nPrimitive (type_id=1): INT(32, SIGNED)\nPrimitive (type_id=1): INT(64, SIGNED)\nPrimitive (type_id=1): INT(8, SIGNED)\nArray (type_id=4): N/A\nPrimitive type: Null\nObject (type_id=3): N/A\nThe number of bytes used to store offsets in the …\nShort String (type_id=2): STRING\nPrimitive (type_id=1): STRING\nPrimitive (type_id=1): TIMESTAMP(isAdjustedToUTC=true, …\nPrimitive (type_id=1): TIMESTAMP(isAdjustedToUTC=false, …\nRepresents a Parquet Variant\n<code>Variant</code> Array.\nA parsed version of the variant array value header byte.\n<code>Variant</code> Metadata\nHeader structure for <code>VariantMetadata</code>\nA <code>Variant</code> Object (struct with named fields).\nHeader structure for <code>VariantObject</code>\nConverts this variant to a <code>bool</code> if possible.\nView the raw bytes (needed by very low-level decoders)\nConverts this variant to a <code>DateTime&lt;Utc&gt;</code> if possible.\nConverts this variant to tuple with a 16-byte unscaled …\nConverts this variant to tuple with a 4-byte unscaled …\nConverts this variant to tuple with an 8-byte unscaled …\nConverts this variant to an <code>f32</code> if possible.\nConverts this variant to an <code>f64</code> if possible.\nConverts this variant to an <code>i16</code> if possible.\nConverts this variant to an <code>i32</code> if possible.\nConverts this variant to an <code>i64</code> if possible.\nConverts this variant to an <code>i8</code> if possible.\nConverts this variant to a <code>NaiveDate</code> if possible.\nConverts this variant to a <code>NaiveDateTime</code> if possible.\nConverts this variant to <code>()</code> if it is null.\nConverts this variant to a <code>&amp;str</code> if possible.\nConverts this variant to a <code>&amp;[u8]</code> if possible.\nGet the dictionary size\nGet a field’s value by index in <code>0..self.len()</code>\nReturns the value of the field with the specified name, if …\nGet a field’s name by index in <code>0..self.len()</code>\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nReturns the argument unchanged.\nGets a dictionary entry by index\nGets an offset array entry by index.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nCalls <code>U::from(self)</code>.\nReturns true if the object contains no key-value pairs\nIs the array of zero length\nWhether the dictionary keys are sorted and unique\nGet all dictionary entries as an Iterator of strings\nReturns an iterator of (name, value) pairs over the fields …\nIterates over the values of this list\nReturns the number of key-value pairs in this object\nReturn the length of this array\nNote: This is <code>offset_size_minus_one</code> + 1\nBuild from the <code>offset_size_minus_one</code> bits (see spec).\nTries to construct the variant metadata header, which has …\nAttempts to interpret <code>bytes</code> as a variant metadata instance.\nAttempts to interpret <code>value</code> as a variant object value.\nAttempts to interpret <code>value</code> as a variant array value.\nCreate a new <code>Variant</code> from metadata and value.\nCreate a new variant with existing metadata\nReturn one unsigned little-endian value from <code>bytes</code>.\nThe variant protocol version")